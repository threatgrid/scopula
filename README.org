* scopula

  #+begin_quote
Scopulae, or scopula pads, are dense tufts of hair at the end of a spiders's
legs

https://en.wikipedia.org/wiki/Scopulae
  #+end_quote

A Clojure library designed to manage a scope convention to handle fine grained
authorization access.

OAuth2 make all the authorization access pass through a single dimension: the
scopes.

=scopes= are case sensitive strings without any space that represent and
authorization access. From OAuth2 RFC
(https://tools.ietf.org/html/rfc6749#section-3.3):

#+begin_quote
The value of the scope parameter is expressed as a list of space-
delimited, case-sensitive strings.  The strings are defined by the
authorization server.  If the value contains multiple space-delimited
strings, their order does not matter, and each string adds an
additional access range to the requested scope.

#+begin_src
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
#+end_src
#+end_quote


In order to manage a fine grained authorizations this lib use a convention
for scope formats.
For example, we often need to distinguish between a full scope that will provide
full access to some resource, and read-only access.
Sometimes we also want to limit the access to some sub-resource.
Here are some example for our convention:

| =users=                     | full access to users resource                 |
| =users/profile=             | access to users profile only                  |
| =users/profile:read=        | access to users profile read-only             |
| =users/profile/email:write= | access to users profile only email write-only |


Mainly =:= is only authorized to split between access =read=/=write=/=rw=
(nothing implies rw)

Sub resources are separated by =/= we can

This library provide helper functions to check that users scope will also grants
=users/profile/email= and =users/profile:read=

We also provide helpers to normalize set of scopes:

#+begin_src clojure
>>> (normalize-scopes #{\"users\" \"users/profile/email:read\" \"admin\"})
#{\"users\" \"admin\"}
#+end_src

as =users/profile/email:read= is redundant it was removed.

Note scopes are meant to be used in an OAuth2 access in mind and thus
are generally manipulated as a set of scopes.

Scopes that do not have any subpath are called /root scopes/.

This is important because it is easy to add some scopes to a set of scopes.
But it is generally impossible to remove just a sub-scope as it would
mean we should know all the sub-paths of some root-scope and add the difference.
Scopes are additive by their nature.

This is why the API only provide a =remove-root-scope= but not a =remove-scope= function.

** Usage

Here is an exerpt of the most useful functions of the API:

- =(is-scope-format-valid? str)=, return true if the string is a valid scope for
  our convention,
- =(is-subscope? scope-to-check super-scope)=, return true if the provided scope
  is a subscope,
- =(access-granted scopes required)=, return =true= if the =required= scope
  are "contained" in the =scopes=,
- =(root-scope scope)= returns the root-scope part of a scope
- =(is-root-scope? scope)= returns true if the scope is a root-scope (access are
  authorized)
- =scope-root= show the root scope of a scope `(= "foo" (scope-root "foo/bar:read"))`

- =(normalize-scopes scopes)= normalize a set of scopes, remove all duplicates,
  and merge scopes with all possible accesses, =normalize-scopes= is idempotent
  ~(= identity (comp normalize-scopes normalize-scopes))~

*** Adding scopes

- =add-scope= to add one scope to a set of scopes
- =scope-union= to make the union of two set of scopes

*** Removing scopes

- =remove-root-scopes= remove some root scopes to a set of scopes
- =remove-root-scope= remove one scope to a set of scopes
- =raw-remove-root-scope= remove one scope to a set of scopes without taking
  care of normalization. You should almost never use this funciton.

*** Scopes intersection

- =scopes-intersection= returns either nil of the maximal intersection between
  two scopes. For example =(scopes-intersection "foo:write" "foo/bar")= returns
  =foo/bar:write=. Notice neither of =foo:write= and =foo/bar= are not subscope
  of the other.
- =scopes-intersect?= return true if two scopes intersects
- =scopes-intersecting= is a non symmetric operation, that returns the list of
  first scopes that intersect with some scopes of the second set of scopes.

*** Notes

The functions starting with =repr= takes scope representation as arguments. You
shall generally not use them. This is why I dont mention them in this document.
Still they are publicly exposed for advanced lib usage.

For a lot more examples take a look at: [[./test/scopula/core_test.clj][./test/scopula/core_test.clj]]

** License

Copyright Â© 2019 Cisco

Distributed under the Eclipse Public License either version 1.0 or (at your
option) any later version.

* scopula

  #+begin_quote
Scopulae, or scopula pads, are dense tufts of hair at the end of a spiders's
legs

https://en.wikipedia.org/wiki/Scopulae
  #+end_quote

A Clojure library designed to manage a scope convention to handle fine grained
authorization access.

OAuth2 make all the authorization access pass through a single dimension: the
scopes.

=scopes= are case sensitive strings without any space that represent and
authorization access. From OAuth2 RFC
(https://tools.ietf.org/html/rfc6749#section-3.3):

#+begin_quote
The value of the scope parameter is expressed as a list of space-
delimited, case-sensitive strings.  The strings are defined by the
authorization server.  If the value contains multiple space-delimited
strings, their order does not matter, and each string adds an
additional access range to the requested scope.

#+begin_src
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
#+end_src
#+end_quote


In order to manage a fine grained authorizations this lib use a convention
for scope formats.
For example, we often need to distinguish between a full scope that will provide
full access to some resource, and read-only access.
Sometimes we also want to limit the access to some sub-resource.
Here are some example for our convention:

| =users=                     | full access to users resource                 |
| =users/profile=             | access to users profile only                  |
| =users/profile:read=        | access to users profile read-only             |
| =users/profile/email:write= | access to users profile only email write-only |


Mainly =:= is only authorized to split between access =read=/=write=/=rw=
(nothing implies rw)

Sub resources are separated by =/= we can

This library provide helper functions to check that users scope will also grants
=users/profile/email= and =users/profile:read=

We also provide helpers to normalize set of scopes:

#+begin_src clojure
>>> (normalize-scopes #{\"users\" \"users/profile/email:read\" \"admin\"})
#{\"users\" \"admin\"}
#+end_src

as =users/profile/email:read= is redundant it was removed.

Note scopes are meant to be used in an OAuth2 access in mind and thus
are generally manipulated as a set of scopes.

Scopes that do not have any subpath are called /root scopes/.

This is important because it is easy to add some scopes to a set of scopes.
But it is generally impossible to remove just a sub-scope as it would
mean we should know all the sub-paths of some root-scope and add the difference.
Scopes are additive by their nature.

This is why the API only provide a =remove-root-scope= but not a =remove-scope= function.

** Usage

Here is an exerpt of the most useful functions of the API:

- =(is-scope-format-valid? str)=, return true if the string is a valid scope for
  our convention,
- =(is-subscope? scope-to-check super-scope)=, return true if the provided scope
  is a subscope,
- =(access-granted scopes required)=, return =true= if the =required= scope
  are "contained" in the =scopes=,
- =(root-scope scope)= returns the root-scope part of a scope
- =(is-root-scope? scope)= returns true if the scope is a root-scope (access are
  authorized)
- =scope-root= show the root scope of a scope `(= "foo" (scope-root "foo/bar:read"))`
- =(normalize-scopes scopes)= normalize a set of scopes, remove all duplicates,
  and merge scopes with all possible accesses, =normalize-scopes= is idempotent
  ~(= identity (comp normalize-scopes normalize-scopes))~


*** Adding scopes

- =add-scope= to add one scope to a set of scopes
- =scope-union= to make the union of two set of scopes

*** Removing scopes

- =remove-root-scopes= remove some root scopes to a set of scopes
- =remove-root-scope= remove one scope to a set of scopes
- =raw-remove-root-scope= remove one scope to a set of scopes without taking
  care of normalization. You should almost never use this funciton.

*** Scopes intersection

- =scope-intersection= returns either nil of the maximal intersection between
  two scopes. For example =(scopes-intersection "foo:write" "foo/bar")= returns
  =foo/bar:write=. Notice neither of =foo:write= and =foo/bar= are not subscope
  of the other.
- =scopes-intersection= returns the intersection between two set of scopes.
- =scopes-intersect?= return true if two scopes intersects
- =scopes-intersecting= is an asymmetric operation, that returns the list of
  first scopes that intersect with some scopes of the second set of scopes.

*** Examples

**** =is-scope-format-valid?=

Return true if the string is a valid scope for our convention,

#+begin_src clojure
(is-scope-format-valid? "foo")
(is-scope-format-valid? "foo/bar")
(is-scope-format-valid? "foo-bar")
(is-scope-format-valid? "foo.bar")
(is-scope-format-valid? "foo/bar:read")
(is-scope-format-valid? "foo/bar:write")
(is-scope-format-valid? "foo/bar:rw")
(is-scope-format-valid? "foo/bar@hsome.dns/sub/url")

(not (is-scope-format-valid? "foo/bar:query"))
(not (is-scope-format-valid? "foo/bar query"))
(not (is-scope-format-valid? "foo/bar\nquery"))
(not (is-scope-format-valid? "https://hsome.dns/sub/url")
#+end_src

**** =is-subscope?=
Return true if the provided scope is a subscope of the the second one

#+begin_src clojure
(is-subscope? "foo" "foo")
(is-subscope? "foo:read" "foo")
(is-subscope? "foo/bar:read" "foo")
(is-subscope? "foo/bar:read" "foo/bar")
(is-subscope? "foo/bar:read" "foo:read")

(not (is-subscope? "root/foo" "foo")
#+end_src

**** =access-granted= and =scopes-superset?=

Return =true= if the first scopes contains all scopes of the second argument.

#+begin_src clojure
(testing "subset is accepted"
  (is (access-granted #{"foo"} #{"foo"})
      "an identical set of scopes should match")
  (is (not (access-granted #{"foo"} #{"foo" "bar"}))
      "A single scope when two are required should not be accepted")
  (is (not (access-granted #{"bar"} #{"foo"})))
  (is (access-granted #{"foo" "bar"} #{"foo"}))
  (is (access-granted #{"foo" "bar"} #{"foo" "bar"}))
  (is (not (access-granted #{"foo" "bar"} #{"foo" "bar" "baz"}))))
(testing "superpath are accepted"
  (is (not (access-granted #{"foo/bar"} #{"foo"})))
  (is (not (access-granted #{"foo/bar/baz"} #{"foo"})))
  (is (not (access-granted #{"foobar/baz"} #{"foo"}))))
(testing "access are respected"
  (is (access-granted #{"foo"}      #{"foo/bar:read"}     ))
  (is (access-granted #{"foo"}      #{"foo/bar/baz:write"}))
  (is (access-granted #{"foo"}      #{"foo/bar/baz:rw"}   ))
  (is (access-granted #{"foo"}      #{"foo/bar/baz:rw"}   ))
  (is (access-granted #{"foo:read"} #{"foo/bar/baz:read"} ))
  (is (not (access-granted #{"foo:read"} #{"foo/bar/baz:write"})))
  (is (access-granted #{"foo" "bar"} #{"foo/bar:read"}))
  (is (access-granted #{"foo" "bar"}      #{"foo/bar/baz:write"}))
  (is (access-granted #{"foo" "bar"}      #{"foo/bar/baz:rw"}   ))
  (is (access-granted #{"foo" "bar"}      #{"foo/bar/baz:rw"}   ))
  (is (access-granted #{"foo:read" "bar"} #{"foo/bar/baz:read"} ))
  (is (not (access-granted #{"foo:read" "bar"} #{"foo/bar/baz:write"})))
  (is (access-granted #{"foo" "bar"} #{"foo/bar:read" "bar"}     ))
  (is (access-granted #{"foo" "bar"} #{"foo/bar/baz:write" "bar"}))
  (is (access-granted #{"foo" "bar"} #{"foo/bar/baz:rw" "bar"}   ))
  (is (access-granted #{"foo" "bar"} #{"foo/bar/baz:rw" "bar"}   ))
  (is (access-granted #{"foo:read" "bar"} #{"foo/bar/baz:read" "bar"}))
  (is (not (access-granted #{"foo:read" "bar"} #{"foo/bar/baz:write" "bar"}))))
#+end_src

**** =root-scope=

Returns the root-scope part of a scope

#+begin_src clojure
  (= (root-scope "foo/bar:read")
     "foo")
#+end_src

**** =is-root-scope?=

Returns true if the scope is a root-scope (access are authorized)

#+begin_src clojure
  (is (is-root-scope? "foo"))
  (is (is-root-scope? "foo:read"))

  (is (not (is-root-scope? "foo/bar:read")))
  (is (not (is-root-scope? "foo/bar")))
#+end_src

**** =normalize-scopes=

Normalize a set of scopes, remove all duplicates, and merge scopes with all
possible accesses, =normalize-scopes= is idempotent:
~(= identity (comp normalize-scopes normalize-scopes))~

#+begin_src clojure
  (= #{"foo/bar"}
     (sut/normalize-scopes #{"foo/bar/baz:read"
                             "foo/bar:write"
                             "foo/bar"}))

  (= #{"foo/bar"}
     (sut/normalize-scopes #{"foo/bar:read"
                             "foo/bar:write"
                             "foo/bar/tux"}))
  (= #{"foo/bar" "root"}
     (sut/normalize-scopes #{"foo/bar:read"
                             "foo/bar:write"
                             "foo/bar/tux"
                             "root"}))
#+end_src

**** =add-scope=

Add a scope to a set of scopes, and take cares of normalizing the result.

#+begin_src clojure
  (is (= #{"foo" "bar"}
         (add-scope "bar" #{"foo"})))

  (is (= #{"foo"}
         (add-scope "foo:read" #{"foo:write"})))

  (is (= #{"foo"}
         (add-scope "foo/bar:read" #{"foo"})))
#+end_src

**** =scope-union=

Union of two set of scopes

#+begin_src clojure
(is (= #{"root2" "foo/bar" "root1"}
    (sut/scope-union #{"foo/bar:read" "root2"}
                     #{"foo/bar:write" "root1"}))
 "Should union the scopes and take care of normalization")
#+end_src

**** =remove-root-scope=

Remove some root scope to a set of scopes

#+begin_src clojure
  (is (= #{"foo/bar"}
         (sut/remove-root-scope "baz"
                                #{"foo/bar:read"
                                  "foo/bar:write"
                                  "baz/quux"}))
      "Should take care of normalization")
  (is (= {:ex-msg
          "We can't remove a sub scope, only root scope can be removed from a set of scopes, note access are supported",
          :ex-data {:scope "baz/quux"}}
         (try (sut/remove-root-scope "baz/quux"
                                     #{"foo/bar:read"
                                       "foo/bar:write"
                                       "baz/quux"})
              (catch Exception e
                {:ex-msg (.getMessage e)
                 :ex-data (ex-data e)})))
      "Should throw an error if trying to remove a sub-scope")
#+end_src

**** =remove-root-scopes= remove one scope to a set of scopes
- =raw-remove-root-scope= remove one scope to a set of scopes without taking
  care of normalization. You should almost never use this funciton.
- =scope-intersection= returns either nil of the maximal intersection between
  two scopes. For example =(scopes-intersection "foo:write" "foo/bar")= returns
  =foo/bar:write=. Notice neither of =foo:write= and =foo/bar= are not subscope
  of the other.
- =scopes-intersection= returns the intersection between two set of scopes.
- =scopes-intersect?= return true if two scopes intersects
- =scopes-intersecting= is an asymmetric operation, that returns the list of
  first scopes that intersect with some scopes of the second set of scopes.

*** Notes

The functions starting with =repr= takes scope representation as arguments. You
shall generally not use them. This is why I dont mention them in this document.
Still they are publicly exposed for advanced lib usage.

For a lot more examples take a look at: [[./test/scopula/core_test.clj][./test/scopula/core_test.clj]]

** License

Copyright © 2019 Cisco

Distributed under the Eclipse Public License either version 1.0 or (at your
option) any later version.
